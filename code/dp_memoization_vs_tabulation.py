# -*- coding: utf-8 -*-
"""DP_memoization_vs_tabulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KPLMwmfQYM2Veuu8dvgJ5sTatSpqBXN8

----------------------------------------

**Dynamic Programming Quick Reference:**

-------------------------------------  

-------------------------------------

***What is needed for DP?***

***What is the difference between Memoization (Top-Down) vs. Tabulation (Bottom-Up)?***

--------------------------------------


This quick reference was made from the GeeksforGeeks DP guide: https://www.geeksforgeeks.org/dsa/introduction-to-dynamic-programming-data-structures-and-algorithm-tutorials/ for personal use and practice/review. I suggest checking out the GeeksforGeeks page directly if you'd like to consult the material.

--------------------------------------------

**top-down** = Memoization (uses recursion + table to store previously computed values)

**bottom-up** = Tabulation (start with small subproblems and build. iterative)

DP NEEDS: optimal substructure (uses optimal results of subproblems) and overlapping subproblems.

----------------------------------------------
"""

# FIBONACCI - Regular Recursion: O(2^(n)) space and time because extra computations

def fib(n):
  if n <= 1:
    return n
  return fib(n-1) + fib(n-2)


if __name__ == "__main__":
  n = 5
  print(fib(n))

# FIBONACCI - MEMOIZATION (Top-Down DP) : O(n) time and space

# TWO FUNCTIONS
# initialize a memo_array with -1 values to start.
# check if the value has already been computed. compute it and store it in array

def fibRec(n, memo_array):

  # BASE CASE
  if n <=1:
    return n
  # Check if already exists
  if memo_array[n] != -1:
    return memo_array[n]
  # Calculate and save output for later
  memo_array[n] = fibRec(n-1, memo_array) + fibRec(n-2, memo_array)
  return memo_array[n]

def fib(n):
  # initialize the array
  memo_array = [-1] * (n+1)
  # call the recursive function
  return fibRec(n, memo_array)


if __name__ == "__main__":
  n = 5
  print(fib(5))

# FIBONNACI TABULATION APPROACH : O(n) time and space too

# initialize a dp array to size n + 1, so dp 0 = 0, dp 1 = 1 etc.
# init starting values in the array and iteratively compute fib numbers
# dp[i] = dp[i-1] + dp[i-2]
# dp[n] = final output for n

def fibo(n):

  # init the array
  dp = dp[0] * (n + 1)

  # store initial values (fib numbers 0 and 1)
  dp[0] = 0
  dp[1] = 1

  for i in range(2, n+1):
    dp[i] = dp[i-1] + dp[i-2]

  return dp[n]

if __name__ == "__main__":
  n = 5
  print(fib(5))

# FIBONNACI : SPACE OPTIMIZED APPROACH : O(n) TIME and O(1) space
# relies on only storing the previously 2 computed values instead of the whole array

# FAVOURITE WAY

def spacefib(n):

  prevprev, prev, curr = 0, 1, 1

  for i in range(2, n+1):

    curr = prev + prevprev
    prevprev = prev
    prev = curr

  return curr



if __name__ == "__main__":
  n = 50
  print(fib(n))

